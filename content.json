{"pages":[{"title":"","text":"Hi there! 👋你好，我是Jerome，是一名后端开发者，我使用Java作为主要开发语言。目前在学习Kotlin，对Rust也非常感兴趣。","link":"/about/index.html"}],"posts":[{"title":"2022年终总结","text":"时间很快啊，一转眼又到了2022年的最后一天，明天就是2023年了，新的一年又开始了，来回顾一下过去的2022。 一年多了，驾照还没拿到手，感觉自己好笨，本来时间就不多，我还在浪费机会。一直期望的拿到驾照出去玩就可以租车了，没想到联动云都快倒闭了我还没拿到驾照😅。 今年7月份，我毕业了，走出了校门，在踏出学校的那一刻，我的青春、快乐的时光，都结束了，不过幸运的是我找到了工作，也遭受到了社会的第一顿毒打，感慨良多。虽然很不舍得学校，但是又不得不面对生活。 在毕业后就忙着找房子、找工作，还好，遇到了一个非常好的房东阿姨，同时也找到了一份能养活自己的工作，虽然工资不高，但这至少是我长这么大第一次完全靠自己在挣钱，挺开心的。 持续了三年多的疫情在今年终于有所改变，突然的政策放开，媒体宣传一百八十度大调转，我不知道这是好事还是坏事，但愿这是好事吧。 在12月份，还有一件重要的事情，那就是疫情管控放开，很不幸，在放开的第一周我就被感染了，发烧两天，烧到39.4度，走路都站不稳，还好有布洛芬救我的命，不过后遗症好像挺严重，我最近可能需要去医院检查一下心肺功能，但愿没问题，我还有好多的事情没做（还想再活五百年）。生病不是一个好事，愿所有人都能身体健康。 截止到2022年12月31日，我们走过了822天，在2022这一年里，我们经常吵架，也差点分手，矛盾越来越多，也越来越不可调和，我有时在想是不是合适，转念一想，哪有啥合不合适，我为什么选择她，那还不是因为喜欢，希望在新的一年里能少点矛盾，多点快乐。 现在感觉自己有一些太安逸了，甚至开始摆烂，每天都是上班，干活，下班，枯燥的生活让人发狂，并且微薄的工资不足以支持我的梦想，我需要做出一些改变让这一潭死水产生一些涟漪，人都是往上走的，下一步我想换一份工作，让工资能有一个较大的改观。 回想一下今年都干了啥，首先是顺利毕业，拿到了毕业证、找到了第一份工作，学到了很多实际的开发经验、Epic游戏仓库有200+游戏，虽然基本不玩，但还是每期必领、有了一点点存款，能让我感觉到一丝丝的安心，不多几件事，明年还需努力。 为了2023年能过上更好的生活，加油吧。","link":"/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"title":"vue快速入门","text":"1、v-if和v-show的区别：v-if：不会在页面上渲染v-show： 会渲染在页面上，但是会通过style=&quot;display: none;&quot;来隐藏起来 用哪个？如果是需要经常改变的，用v-show，这样性能损失小一些 2、vuex快速入门首先安装：npm install vuex --save然后新建src/store/index.js 1234567891011121314151617181920212223242526/* src/store/index.js */// 导入 Vueimport Vue from 'vue'// 导入 Vuex 插件import Vuex from 'vuex'// 把 Vuex 注册到Vue 上Vue.use(Vuex)export default new Vuex.Store({ // 在开发环境开启严格模式 这样修改数据 就必须通过 mutation 来处理 strict:products.env.NODE_ENV !== 'production', // 状态 state: { }, // 用来处理状态 mutations: { }, // 用于异步处理 actions: { }, // 用来挂载模块 modules: { }}) 然后记得在main.js里面挂载 使用：把所有需要共享的状态都放在state里面,比如 name: '张三', age: 21 12345678910111213141516171819/* src/store/index.js */// 导入 Vueimport Vue from 'vue'// 导入 Vuex 插件import Vuex from 'vuex'// 把 Vuex 注册到Vue 上Vue.use(Vuex)export default new Vuex.Store({ state: { name: '张三', age: 21, }, mutations: {}, actions: {}, modules: {},}) 取值：有两种方法，1：直接使用 this.$store.state[属性] ，（this 可以省略） 123456&lt;template&gt; &lt;div id=&quot;app&quot;&gt; {{ this.$store.state.name }} {{ this.$store.state.age }} &lt;/div&gt;&lt;/template&gt; 直接用this.$store.state.name是最简单的，如果要改变值直接this.$store.state.name = '李四'就可以了，或者this.$store.state[name] = '李四'2：通过 mapState把 store 映射到 组件的计算属性，就相当于组件内部有了 state 里的属性 12345678910111213141516171819202122&lt;template&gt; &lt;div id=&quot;app&quot;&gt; {{ name }} {{ age }} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 从 Vuex 中导入 mapStateimport { mapState } from 'vuex'export default { name: 'App', computed: { // 将 store 映射到当前组件的计算属性 ...mapState(['name', 'age']) }}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 另外还有getter、module、action暂时不管，用不上 3、vue router快速入门安装和使用路由： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576第一步：导入路由对象，并且调用 Vue.use(VueRouter)第二步：创建路由实例，并且传入路由映射配置第三步：在Vue实例中挂载创建的路由实例import Vue from 'vue' import VueRouter from 'vue-router' 路由懒加载const Home = () =&gt; import('../components/Home.vue')const About = () =&gt; import('../components/About.vue')const Message = () =&gt; import('../components/Message.vue')const news = () =&gt; import('../components/news.vue')Vue.use(VueRouter)使用vue-router的步骤:第一步: 创建路由组件第二步: 配置路由映射: 组件和路径映射关系第三步: 使用路由: 通过&lt;router-link&gt;和&lt;router-view&gt;// 定义路由const routers = [ { path: '/', redirect: '/home' }, { path: '/home', component: Home, // 嵌套路由 children: [ { path: 'message', // 或者这样更快捷，不需要定义变量 component: () =&gt; import('../components/Message.vue') }, { path: 'news', component: News, }, { path: '', redirect: 'message' } ] }, { path: '/about', component: About }]// 创建router实例const router = new VueRouter({ routers, // 使用HTML5的history模式 mode: 'history', // 修改active-class属性的默认类名（router-link-active） LinkActiveClass: 'active' })// 导出router实例export default router// 挂载到vue实例new Vue({ el: '#app', router, render: h =&gt; h(APP)})&lt;router-link&gt;: 该标签是一个vue-router中已经内置的组件, 它会被渲染成一个&lt;a&gt;标签.&lt;router-view&gt;: 该标签会根据当前的路径, 动态渲染出不同的组件.网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和&lt;router-view&gt;处于同一个等级.在路由切换时, 切换的是&lt;router-view&gt;挂载的组件, 其他内容不会发生改变. 页面路由跳转：用this.$router.push('/home')把当前需要跳转的地址push进去就好了 1234567891011&lt;button @click=&quot;linToHome&quot;&gt;首页&lt;/button&gt;&lt;script&gt; export default { name: 'App', methods: { linToHome() { this.$router.push('/home') } } }&lt;/script&gt; 到这里，我们已经可以跳转页面了，但是还不够，肯定还需要携带参数动态路由：params： 配置格式：/router/:id 传递方式： 在path后面跟上对应的值 传递后形成的路径： /router/123 或者 /router/abc 12345678910111213//拿到用户名（userId是自己router中定义的路径）{ path: '/user/:userId', component: User}&lt;router-link to=&quot;/user/123&quot;&gt;用户&lt;/router-link&gt;&lt;div&gt; &lt;h3&gt;{{$route.params.userId}}&lt;/h3&gt;&lt;/div&gt;{{this.$route.params.userId}} query： 配置格式： /router，也就是普通配置 传递方式： 对象中使用query的key作为传递方式 传递路径： /router?id=123 或者 /router?id=abc 1234//获取参数{{ $route.params }}{{ $route.query }} 实际传递参数的方式： 12345678910111213&lt;script&gt;export default { name: 'App', methods: { toProfile() { this.$router.push({ path: '/profile' + 123, query: {name: 'tom', age: 20} }) } }}&lt;/script&gt; 后面的嵌套路由、路由守卫、懒加载啥的暂时不管","link":"/2023/06/22/vue%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"如何使用hexo写文章","text":"0、前言我们已经使用hexo搭建好了平台，需要我们去一点一点让它丰富起来 1、创建文章首先我们需要先创建一个md文件，使用下面命令来生成一个md文件 1hexo new &quot;标题&quot; 这个就是我们的文章模板，我们就在这里写文章，这也是我们的文章存档 2、清理缓存在每一次编译部署之前最好都clean一下我们可以使用 1hexo clean 来清理静态缓存文件，保证文件都是最新更改的 3、生成静态文件使用下面命令来生成静态文件，g -&gt; generate 1hexo g 我们在上面md文件里写的文章是不能被浏览器解析的，所以需要转换成html页面 4、提交部署文章编译好了之后就需要提交到github上去，d -&gt; deploy 1hexo d 静静等待提交成功，如果提交失败，可能是账号填写错误，仔细检查一下，或者是因为网络不好，因为github经常会被墙不太稳定，多试试 5、完结撒花！！稍等一下就可以访问到更改了","link":"/2022/01/08/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E5%86%99%E6%96%87%E7%AB%A0/"},{"title":"我的第一篇博客","text":"你好，这是我的第一篇博客！这篇博客是使用Hexo搭建在Github Page上的，使用Markdown编写。以后我将在此记录和分享我学习过程中的一些东西！","link":"/2021/10/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"获取免费域名","text":"网站：https://www.freenom.com 网站比较辣鸡，有时候会访问不了，有时候又会无响应或者频繁让你登录 1、注册一个账号首先要有一个账号，推荐使用gmail，别的邮箱应该也可以，没试过 2、登录到freenom登录需要挂梯子，节点最好选择美国的 3、查找域名然后在右上角菜单选择注册一个新域名，输入想要的域名，点击查找，会看到域名是否可用，如果可用，就添加到购物车里并选择注册时间到12个月，点击下一步，到提交订单这里停下来，然后是最重要的一步 4、更改资料这是最重要的的一步，关乎到能否注册成功，因为freenom是免费的域名注册商，为了防止恶意注册，它会有一个机器来判定你的ip和地址，如果我们使用自己的真实地址和资料，大概率会失败，所以，我们需要去将地址更改为自己节点的地址，资料可以百度身份生成，然后填写好，提交，这个时候就可以回到购物车了，现在点击下单，稍等就注册成功了，改资料这个步骤不能跳过，后面续费，注册别的域名也可以尝试改资料。 5、注册成功注册成功之后就可以把解析服务器改到阿里云或者腾讯云，但是我们注册的.ml .tk .gq .ga这些域名都是阿里云不识别的，所以要放到别的域名服务商 6、更改解析服务器把域名解析到cloudflare就可以后续的操作，我们在freenom-Services-My Domains找到自己的域名，点击后面的Manage Domain，找到nameservers，设置为enter below，填入cloudflare的解析服务器 7、在cloudflare添加域名我们在cloudflare添加自己的域名，就可以让服务商来帮我管理相关域名、防止黑客攻击等，然后在添加解析规则，添加两个CNAME，名称为域名，内容为想要指向的网址，例如：CNAME : songizhu.tk : jeromest.github.io，再添加一条www，CNAME : www : jeromest.github.io 8、告一段落到这里就完成了域名注册和解析的过程，下面来配置github 9、配置github使用githubpage来生成一个静态网站，略过过程，挖个坑以后再填，将songizhu.tk这个域名映射到jeromest.github.io就可以使用我们自己的域名来访问了 10、完结撒花！！","link":"/2022/01/08/%E8%8E%B7%E5%8F%96%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D/"},{"title":"搭建hexo博客","text":"1、新建仓库首先在 github 新建一个仓库用来存放我们的博客文件，由于要使用 Github Page 功能，所以仓库名称要写成用户名.github.io的形式。 2、配置环境工欲善其事必先利其器，首先要安装nodejs，hexo依赖于这个运行，其次是git，用于管理版本和向远程仓库推送代码，怎么安装自己百度。安装完成要进行测试，在命令行输入node --version和git --version如果有版本信息就行了。 3、下载脚本可以使用脚本来快速部署博客，脚本自己在github找。 4、生成ssh秘钥由于我们最终需要把博客部署到github上面，那我们平时更新博客就要手动提交推送，甚至有时候还要登陆账号，很麻烦，这时候就需要一个快速提交代码的办法，生成ssh，ssh是一个凭证，储存在C盘用户目录下，每次提交的时候github就知道这台电脑是可信任的，不用登陆就可以提交代码。 5、部署到这里博客应该可以在本地预览了，但是现在只能你自己看，想让别人看到就要把博客部署到github，配置博客目录下的_config.yml文件，拉到最下面，填写仓库地址和分支名称，注意，这里分支名称不能是master，要写main，不然hexo会自动在远程仓库新建一个分支，这样是不行滴。最后运行./up.sh生成静态博客内容并推送到远程仓库。 6、搞定推送完成后去github查看是否成功，稍等几分钟等github解析，然后在地址栏输入用户名.github.io就可以查看博客。 备注其实，去看hexo官网更好，文档清晰，简单快捷。官网：Hexo","link":"/2022/12/01/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2/"},{"title":"设计模式","text":"菜鸟教程：设计模式 首先，设计模式主要分为三类，还有一个J2EE模式不常用： 创建型模式（5种）这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 结构型模式（8种）这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式（12种）这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 先看一遍菜鸟教程 1、工厂模式","link":"/2022/12/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"年终总结","slug":"年终总结","link":"/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"教程","slug":"教程","link":"/tags/%E6%95%99%E7%A8%8B/"},{"name":"FristBlog","slug":"FristBlog","link":"/tags/FristBlog/"},{"name":"域名","slug":"域名","link":"/tags/%E5%9F%9F%E5%90%8D/"},{"name":"笔记","slug":"笔记","link":"/tags/%E7%AC%94%E8%AE%B0/"}],"categories":[]}